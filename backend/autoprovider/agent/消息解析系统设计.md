# 消息加载和解析系统

## 功能概括

消息加载和解析的功能就是，后端提供一个接口让前端去查询该用户某个项目的某个会话下的所有对话信息。

## 输入

前端应该要在接口处明确输入一个参数，session_id。



## 处理

后端需要写一个接口：getSessionOperations。可以直接延用现有的接口内容，在原有内容上进行修改即可。

这个接口的获取数据分为用户数据和系统数据两部分的获取。

### 系统数据

获取到session_id之后，按照惯例应该先要对参数进行校验，例如校验这个session_id对应的项目是不是这个用户的，项目的状态是否被删除等，这个session_id的状态是否已经被删除等

```sql
create table session_record
(
    session_id     varchar(50)                            not null comment '会话ID，由系统生成唯一标识'
        primary key,
    project_id     varchar(50)                            not null comment '所属项目ID，来源于project_info表的project_id',
    session_title  varchar(200) default '新会话'          null comment '会话标题',
    session_status tinyint      default 0                 null comment '会话状态：0-正常使用，1-已删除',
    create_time    datetime     default CURRENT_TIMESTAMP null comment '创建时间'
)
    comment '会话记录表' collate = utf8mb4_unicode_ci;
```

在校验完之后，首先应该要根据这个session_id获取到当前会话下所有的work_id。

```sql
create table work_record
(
    work_id     varchar(50)                        not null comment '工作id'
        primary key,
    create_time datetime default CURRENT_TIMESTAMP not null comment '工作开始时间',
    work_status tinyint  default 0                 null comment '工作状态，0是正常，1是操作撤回',
    session_id  varchar(50)                        null comment '对应的session的id'
)
    comment '工作记录，一个工作包含多个dialogue';


```



在autoprovider平台中，我们有一个"work块“的概念，因为我们希望AI的工作是以任务为驱动而不是对话为驱动的，也就是说，用户发送一次prompt，我们会在后台系统中设置一个循环，多次向AI发送请求，直到AI完成一次工作（即work块），那么在这次work中会发生多次dialogue，每次dialogue中，AI可能会进行多个function call。每一个function的调用都是一个operation。最终要返回给前端的，就是这个operation

那么我们在work表中查询到所有状态为0的work_id，那么我们就需要去获取到每个work的所有dialogue。三者的关系如图所示

![image-20251125203005014](C:\Users\jae\AppData\Roaming\Typora\typora-user-images\image-20251125203005014.png)

处理的最终产物还是获取到所有的operation。

在获取到所有的operation之后，我们需要对他们进行打包，为了让前端更好的处理解析和展示，我们需要使用一个特定的json格式

```json
{
    { //这里是work1
    	{//这里是operation1
    		"operation_code":"....",
		},
		{//这里是operation2
            "operation_code":"....",
        }，
		{//这里是operation3
            "operation_code":"....",
        }
	},
	{ //这里是work2
        ...
    },
	{ //这里是work3
        ....
    },
}
```

按照work对他们进行区分，每个work块里面有多个operation。

接下来我们详细讲一下operation是什么内容，我们先看一下operation的表

```sql
create table operation_record
(
    operation_id     varchar(50)                        not null comment '操作ID，由系统生成唯一标识'
        primary key,
    dialogue_id      varchar(50)                        not null comment '对话ID，来源于dialogue_record表的dialogue_id',
    operation_code   longtext                           not null comment '操作代码，解析前整个方法标签的代码',
    create_time      datetime default CURRENT_TIMESTAMP null comment '创建时间',
    operation_method varchar(200)                       null comment '操作方法，操作的function名称',
    operation_status tinyint  default 0                 null comment '操作状态：0-正常应用，1-被回撤',
    operation_index  int                                null
)
    comment '操作记录表' collate = utf8mb4_unicode_ci;
```

operation中存储的一个关键键：operation_code。这个是前端展示的最重要的内容，在前端中要使用什么样的组件来展示这条operation就是看这个operation_code的内容。

operation_index就是每个dialogue中operation执行的先后顺序。

我们要的处理过程是这样的：

获取到前端传过来的session_id--->查询所有的work_id--->查询所有的dialogue_id---->查询所有的operation---->打包返回数据，按照work_id分成每一个块。

### 用户数据

用户数据比较简单，就是这次work中用户发送的prompt，注意不是系统为了驱动任务进行发送给AI的消息。

我们来看一下dialogue表

```sql
create table dialogue_record
(
    dialogue_id     varchar(50)                        not null comment '对话ID，由系统生成唯一标识'
        primary key,
    create_time     datetime default CURRENT_TIMESTAMP null comment '创建时间',
    role_type       varchar(20)                        not null comment '发起角色：user-用户，assistant-AI，tool-工具调用',
    content         text                               not null comment '对话内容，如果是tool角色，则是工具调用的结果',
    dialogue_status tinyint  default 0                 null comment '对话状态：0-正常使用，1-已撤回',
    dialogue_index  int                                not null comment '对话索引，用于记录对话先后顺序，实现回撤功能',
    dialogue_sender varchar(20)                        null comment '发送这条消息的平台，client和system，客户端和系统都可以使用user这个role给AI发送消息',
    tool_call_id    varchar(125)                       null comment '记录工具调用的tools id',
    work_id         varchar(50)                        null comment '对应的work',
    session_id      varchar(50)                        null,
    tool_call       text                               null
)
    comment '对话记录表' collate = utf8mb4_unicode_ci;
```

在表中，我们应该要筛选

role_type是user的，并且dialogue_sender是client的，并且status是正常的，content就是用户的在本次work发送的消息。

### 组合打包

在获取到两份数据之后，我们就要将他们一起打包发送给前端，其实很好理解，就跟正常的对话消息查询接口一样，只不过我们返回的消息换成了操作，并且返回的单位不是消息，而是work。

在前端中展示的数据如图：

![image-20251125203944434](C:\Users\jae\AppData\Roaming\Typora\typora-user-images\image-20251125203944434.png)

我们接口返回的内容也是以work为单位的

```json
{
    { //这里是work1
    	{ //这里是user messages
    		{
    			"user_content":"..."
			}
		},
		{ //这里是operations
            {//这里是operation1
    			"operation_code":"....",
			},
			{//这里是operation2
            	"operation_code":"....",
        	}，
			{//这里是operation3
            	"operation_code":"....",
       		}
        }
	},
	{ //这里是work2
        ...
    },
	{ //这里是work3
        ....
    },
}
```

注意，这里的operation_code必须要按照顺序进行返回！需要从高往低依次排序

session----work排序---dialogue排序----operation排序

同一个session中要按照work的创建时间排序，越早越靠前，在同一个work中要按照dialogue的index进行排序，index越小越中的operation越靠上---最后按照operation_index进行排序，越少越靠上

## 输出

输出格式如下的一个session中的所有聊天数据

```json
{
    { //这里是work1
    	{ //这里是user messages
    		{
    			"user_content":"..."
			}
		},
		{ //这里是operations
            {//这里是operation1
    			"operation_code":"....",
			},
			{//这里是operation2
            	"operation_code":"....",
        	}，
			{//这里是operation3
            	"operation_code":"....",
       		}
        }
	},
	{ //这里是work2
        ...
    },
	{ //这里是work3
        ....
    },
}
```



# 补充--work的记录

那么我们同理要在合适的地方记录work

AI的对话逻辑如下：

AgentWork发起对话【创建一个work，创建dialogue_index】----AgentChat被调用进行对话【创建一个dialogue，创建一个operation_index，dialogue_index++】---匹配到function_call---调用functionCalling---调用callFunction【记录一个operation,operation_index++】



对于operation的设计，关于operation_index的设计

每一个AIfunction的return格式

```javascript
    // {
    //   status:0,//0是成功，1是失败
    //   message:"调用成功或者失败的消息，只能是字符串",
    //   data:"每个function自己定义data里面的内容，可能是任何形式，比如字符串，对象，数组等",
    //   operationCode:["operation_code1",....]只能是数组形式,item必须是string"
    // }
```



修改一下这个js文件中createFile方法的return，按照下面的内容格式

```javascript
{
  status: 0, // 0是成功，1是失败
  message: "调用成功或者失败的消息，只能是字符串",
  data: {
    "/frontend/src/views/login.vue": "创建结果：create success",
    "/frontend/src/components/auth.floder": "创建结果：create success", 
    "/frontend/src/utils/helpers.js": "创建结果：create fail【父目录不存在】",
    "/frontend/src/assets/styles/login.css": "创建结果：create fail【文件已存在】",
    "/frontend/src/components/UserPanel.vue": "创建结果：create fail【权限不足】",
    "summary": {
      "total_items": 5,
      "successful_creations": 2,
      "failed_creations": 3,
      "items_by_type": {
        "files": 4,
        "folders": 1
      },
      "failed_details": [
        {
          "file_path": "/frontend/src/utils/helpers.js",
          "reason": "父目录不存在",
          "type": "file"
        },
        {
          "file_path": "/frontend/src/assets/styles/login.css", 
          "reason": "文件已存在",
          "type": "file"
        },
        {
          "file_path": "/frontend/src/components/UserPanel.vue",
          "reason": "权限不足", 
          "type": "file"
        }
      ]
    }
  }
}
```

其中在当前方法的data中，返回的内容应该是：

```javascript
data:{
	"fileName1":'创建结果：create success/create fail【创建失败要带上失败原因】',
	"fileName2":"....."
	.....
}
```



delete

```javascript
{
  status: 0, // 0是成功，1是失败
  message: "调用成功或者失败的消息，只能是字符串",
  data: {
    "/frontend/src/views/login.vue": "删除结果：delete success",
    "/frontend/src/components/old.floder": "删除结果：delete success",
    "/frontend/src/assets/obsolete.css": "删除结果：delete fail【文件不存在】",
    "/frontend/src/utils/helpers.js": "删除结果：delete fail【权限不足】",
    "summary": {
      "total_files": 4,
      "successful_deletions": 2,
      "failed_deletions": 2,
      "failed_details": [
        {
          "file_path": "/frontend/src/assets/obsolete.css",
          "reason": "文件不存在"
        },
        {
          "file_path": "/frontend/src/utils/helpers.js", 
          "reason": "权限不足"
        }
      ]
    }
  }
}
```



edit_file

```javascript
{
  status: 0, // 0是成功，1是失败
  message: "调用成功或者失败的消息，只能是字符串",
  data: {
    "file_path": "编辑结果：edit success/edit fail【编辑失败要带上失败原因】",
    "operations": [
      {
        "operation_index": 0,
        "result": "操作结果：success/fail【失败原因】",
      },
      {
        "operation_index": 1, 
        "result": "操作结果：success/fail【失败原因】",
      }
    ],s
    "summary": {
      "total_operations": 2,
      "successful_operations": 2,
      "failed_operations": 0,
      "total_lines_modified": 19
    }
  }
}
```



read_file

```javascript
{
  status: 0, // 0是成功，1是失败
  message: "调用成功或者失败的消息，只能是字符串",
  data: {
    "/frontend/src/components/LoginPanel.vue": {
      "result": "读取结果：read success",
      "content": "<template>\n  <div class=\"login-panel\">\n    <h2>用户登录</h2>\n    <!-- 登录表单内容 -->\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'LoginPanel',\n  // 组件逻辑\n}\n</script>",
      "file_size": 256,
      "lines_count": 15
    },
    "/frontend/src/utils/helpers.js": {
      "result": "读取结果：read success", 
      "content": "export function formatDate(date) {\n  return date.toISOString().split('T')[0];\n}\n\nexport function validateEmail(email) {\n  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n}",
      "file_size": 128,
      "lines_count": 8
    },
    "/frontend/src/assets/config.json": {
      "result": "读取结果：read fail【文件不存在】",
      "content": null,
      "file_size": 0,
      "lines_count": 0
    },
    "/frontend/src/components/auth.floder": {
      "result": "读取结果：read fail【文件夹无法读取】",
      "content": null, 
      "file_size": 0,
      "lines_count": 0
    },
    "/frontend/src/styles/main.css": {
      "result": "读取结果：read fail【权限不足】",
      "content": null,
      "file_size": 0,
      "lines_count": 0
    },
    "summary": {
      "total_files": 5,
      "successful_reads": 2,
      "failed_reads": 3,
      "total_content_size": 384,
      "failed_details": [
        {
          "file_path": "/frontend/src/assets/config.json",
          "reason": "文件不存在"
        },
        {
          "file_path": "/frontend/src/components/auth.floder",
          "reason": "文件夹无法读取"
        },
        {
          "file_path": "/frontend/src/styles/main.css",
          "reason": "权限不足"
        }
      ]
    }
  }
}
```



sql

```javascript
{
  status: 0, // 0是成功，1是失败
  message: "调用成功或者失败的消息，只能是字符串",
  data: {
    "sql": "SELECT * FROM users WHERE id = 1;",
    "result": "执行结果：execute success",
    "execution_time": "0.045s",
    "affected_rows": 1,
    "rows": [
      {
        "id": 1,
        "username": "admin",
        "email": "admin@example.com",
        "created_at": "2024-01-15 10:30:00"
      }
    ],
    "schema_info": {
      "table": "users",
      "columns": ["id", "username", "email", "created_at"],
      "operation_type": "SELECT"
    },
    "query_summary": {
      "rows_returned": 1,
      "columns_count": 4
    }
  }
}
```



bash

```javascript
{
  status: 1,
  message: "部分命令执行失败",
  data: {
    "commands": [
      {
        "working_directory": "/frontend",
        "instruction": "npm run build",
        "result": "执行结果：execute success",
        "exit_code": 0,
        "output": "Build completed successfully",
        "output_type": "stdout"
      },
      {
        "working_directory": "/invalid/path",
        "instruction": "ls -la",
        "result": "执行结果：execute fail【工作目录不存在】",
        "exit_code": 1,
        "output": "bash: cd: /invalid/path: No such file or directory",
        "output_type": "stderr"
      },
      {
        "working_directory": "/frontend",
        "instruction": "rm -rf /",
        "result": "执行结果：execute fail【危险操作被阻止】",
        "exit_code": 1,
        "output": "Error: Destructive operation blocked by safety restrictions",
        "output_type": "stderr"
      },
      {
        "working_directory": "/frontend",
        "instruction": "unknown_command",
        "result": "执行结果：execute fail【命令不存在】",
        "exit_code": 127,
        "output": "unknown_command: command not found",
        "output_type": "stderr"
      }
    ],
    "summary": {
      "total_commands": 4,
      "successful_commands": 1,
      "failed_commands": 3,
      "success_rate": "25%",
      "failed_details": [
        {
          "command_index": 1,
          "reason": "工作目录不存在",
          "suggestion": "请检查工作目录路径是否正确"
        },
        {
          "command_index": 2,
          "reason": "危险操作被阻止",
          "suggestion": "请使用安全的操作命令"
        },
        {
          "command_index": 3,
          "reason": "命令不存在",
          "suggestion": "请检查命令拼写或是否已安装相关工具"
        }
      ]
    }
  }
}
```



create_todolist

```javascript
{
  status: 0, // 0是成功，1是失败
  message: "调用成功或者失败的消息，只能是字符串",
  data: {
    "todolist_info": {
      "todolist_name": "100001-1740321211-新任务",
      "todolist_id": "TL_20250115143000_001",
      "creation_time": "2025-01-15 14:30:00",
      "result": "创建结果：create success",
      "total_items": 3,
      "completed_items": 0,
      "pending_items": 3
    },
    "todo_items": [
      {
        "item_id": "TD_001",
        "title": "设计用户登录界面",
        "status": "pending",
        "result": "添加结果：add success",
        "created_time": "2025-01-15 14:30:01"
      },
      {
        "item_id": "TD_002", 
        "title": "实现用户认证逻辑",
        "status": "pending",
        "result": "添加结果：add success",
        "created_time": "2025-01-15 14:30:02"
      },
      {
        "item_id": "TD_003",
        "title": "编写单元测试用例",
        "status": "pending", 
        "result": "添加结果：add success",
        "created_time": "2025-01-15 14:30:03"
      }
    ],
    "summary": {
      "todolist_created": true,
      "items_added": 3,
      "items_failed": 0,
      "completion_rate": "0%"
    }
  }
}
```



donetodo

```javascript
{
  status: 0, // 0是成功，1是失败
  message: "调用成功或者失败的消息，只能是字符串",
  data: {
    "todolist_info": {
      "todolist_name": "100001-1740321211-新任务",
      "todolist_id": "TL_20250115143000_001",
      "result": "操作结果：execute success",
      "total_items": 3,
      "completed_before": 0,
      "completed_after": 2,
      "pending_after": 1,
      "completion_rate": "66.7%"
    },
    "operation_results": [
      {
        "title": "设计用户登录界面",
        "item_id": "TD_001",
        "result": "标记结果：mark success【已成功标记为完成】",
        "previous_status": "pending",
        "current_status": "completed",
        "completion_time": "2025-01-15 15:20:05"
      },
      {
        "title": "实现用户认证逻辑",
        "item_id": "TD_002",
        "result": "标记结果：mark success【已成功标记为完成】",
        "previous_status": "pending",
        "current_status": "completed",
        "completion_time": "2025-01-15 15:20:06"
      },
      {
        "title": "编写单元测试用例",
        "item_id": "TD_003",
        "result": "标记结果：mark success【项目已是完成状态】",
        "previous_status": "completed",
        "current_status": "completed",
        "completion_time": "2025-01-15 14:45:00"
      }
    ],
    "summary": {
      "total_operations": 3,
      "successful_operations": 3,
      "failed_operations": 0,
      "newly_completed": 2,
      "already_completed": 1
    }
  }
}
```



# 前端集合

我们需要把接口getSessionOperations使用到前端中去，首先还是最简单的需要配置fc_api.js。

配置完之后我们需要在work-chat-pannel组件中使用请求拦截器调用接口，在我们平台中的理念是让最高层级的组件或者页面来获取数据，然后传递数据给低层级组件进行展示，做到数据和展示数据功能分离

获取到操作记录之后，比较简单，就是把原来的getSessionDialogue接口改成getSessionOperations使用。然后就是接口返回的格式也不一样了， 需要把原来的流程改成适配getSessionOperations的