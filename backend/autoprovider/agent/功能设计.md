# 任务并发限制

我现在需要实现一个用户任务并发限制的功能。用户在向服务器发送创建任务请求的时候，调用接口时系统会先判断用户的会员类型，根据不同会员类型设定好的并发数量限制判断是否允许用户再创建新任务。

具体设计如下：

**功能概述：**

首先用户会调用一个接口：createproject

这个接口首先需要通过 token 验证器把 userid 提取出来，然后接口第一步需要先进行用户的已经进行项目数和会员类型判断：

> 会员类型和任务并发数关系
> | vip_type | concurrency |
> | -------- | ----------- |
> | free | 1 |
> | pro | 3 |
> | ultra | 5 |
> | ultimate | 10 |

这里我们需要使用到 redis 来进行缓存计数，需要记录用户的会员配置和用户已经进行了的任务数量。

【这里的设计逻辑是，访问该接口的时候首先从 redis 中获取到相关记数，如果没有到达限制则进行下一步并更新到 mysql 和 redis 中，到达限制则直接 res.send 回去。如果在 redis 中没有找到这个用户的记录，则直接从 mysql 中获取并更新到 redis，然后再判断是否达到限制并做出下一步处理】

这里需要注意，将 redis 的操作要单独做成 utils。主要实现下面几个方法并导出

- 查询是否达到限制【返回 true 或 false】
- 更新 redis 记录【这里是更新 redis 中的记录】

再往后走，如果判断通过了，用户可以继续创建新的任务，那么就直接调用 initNewProject.js，这个方法的实现你不需要关心，如果创建一个新任务成功的时候，这个方法会返回新建的项目的一些信息回来，如果创建失败，会返回一个错误信息。这是一个 promise，你只需要判断 return 中的 infoObject 是否含有 error 键即可，如果没有说明初始化成功了，你可以将 infoObject 直接返回给前端，代表新建项目成功，否则就是失败

一些补充信息：

1. 怎样判断是否有任务正在进行？我们平台的 project 状态，project_status，他只有两个值：0-使用中，1-已删除。可以直接判断该用户 id 的使用中的项目数量来进行判断。

你可能需要使用到的一些 sql 表：

```sql
create table user_info
(
    user_id     varchar(50)                                                         not null comment '用户ID'
        primary key,
    account     varchar(100)                                                        not null comment '账号',
    username    varchar(100)                                                        not null comment '用户名',
    vip_type    enum ('free', 'pro', 'ultra', 'ultimate') default 'free'            null comment '会员类型',
    credits     int                                       default 0                 null comment '积分',
    create_time datetime                                  default CURRENT_TIMESTAMP null comment '创建时间',
    status      int                                       default 0                 null comment '账号状态，0是正常使用，1是已注销',
    constraint uk_account
        unique (account)
)
    comment '用户信息表' collate = utf8mb4_unicode_ci;

create table project_info
(
    project_id     varchar(50)                            not null comment '项目ID，由系统生成唯一标识'
        primary key,
    author_id      varchar(50)                            not null comment '作者ID，来源于user_info表的user_id',
    project_name   varchar(200) default '新项目'          null comment '项目名称',
    project_icon   varchar(500) default ''                null comment '项目图标地址',
    project_url    varchar(500) default ''                null comment '项目访问地址',
    project_status tinyint      default 0                 null comment '项目状态：0-使用中，1-已删除',
    create_time    datetime     default CURRENT_TIMESTAMP null comment '创建时间'
)
    comment '项目信息表' collate = utf8mb4_unicode_ci;
```

# 初始化项目

现在我需要你帮我开发 initNewProject 方法，这个方法是用户创建新项目成功之后，系统对于新项目进行初始化的操作：

**功能概述**

系统在确认并批准了用户创建新项目的请求之后，createProject 接口会调用该方法，该方法首先会在 mysql 的 project-info 表中插入一条新的数据，将 project_id 取回来，然后将系统准备好的 template 文件夹复制一份，并复制到对应的目录，并将 template 文件重新命名为 project_id 的名称（下面称该文件夹为项目文件）。然后进行一系列的操作（对项目中某些文件进行详细编辑）并返回这个项目的信息给方法调用方。

**功能实现**

方法接受的参数只需要(user_id)

首先，你需要完成一个 mysql 的数据插入，并且获取到 Project-id 回来。

然后复制一份 template 文件夹(template 文件的位置是一个常量，我会自己配置)及其里面的内容，并且将 template 的名称重命名为：project-id 的文件夹。

然后将该文件移动到特定位置（这里可以写一个常量，我会自己设置）

然后再写一个 initScript，initNewProject 在将文件移动到特定位置之后调用这个方法。（可以是异步调用），这个 initScript 你不需要关心他的代码组成，因为我们会一直对这个函数的内容进行变化，你只需要知道 initScript 主要的作用就是对复制过去的文件进行一些初始文件的配置和包的安装，例如运行 npm install 等命令。

initScript 在初始化完成之后会返回一个 true 结果回去代表初始化完成

但是 initNewProject 的 return 其实可以不需要等待 initScript 的 true，他们应该是异步的，initNewProjce 在成功移动文件之后调用 InitScript 之后就可以返回 infoObject 回去了。

**资料补充**

你可能会用到的一些内容：

```sql
create table project_info
(
    project_id     varchar(50)                            not null comment '项目ID，由系统生成唯一标识'
        primary key,
    author_id      varchar(50)                            not null comment '作者ID，来源于user_info表的user_id',
    project_name   varchar(200) default '新项目'          null comment '项目名称',
    project_icon   varchar(500) default ''                null comment '项目图标地址',
    project_url    varchar(500) default ''                null comment '项目访问地址',
    project_status tinyint      default 0                 null comment '项目状态：0-使用中，1-已删除',
    create_time    datetime     default CURRENT_TIMESTAMP null comment '创建时间'
)
    comment '项目信息表' collate = utf8mb4_unicode_ci;
```

# 表设计

- 会话记录表：
  - 会话 id
  - 项目 id//这个会话属于哪个项目的
  - 创建时间
  - 会话状态：0 是正常使用，1 是已经被删除
- 对话记录表
  - 对话 id
  - 会话 id//这个对话属于哪个会话的
  - 创建时间
  - 发起角色//用户或者 AI
  - 对话内容//这个会话的内容
  - 对话状态：0 是正常使用，1 是被撤回
  - 对话索引：这个用于记录对话的先后顺序，直接使用数字的，用于实现对话操作回撤功能的

# 积分管理系统

我们需要开发一个新的业务系统：积分管理

我们平台有很多操作会消耗积分，我们现在需要把积分管理的操作抽象出来，包含两个主要部分：

**消耗的积分数量计算**和**更新积分数量**

首先我们来说一下消耗的积分数量计算：这里需要写一个方法：creditsCalculate

这个方法需要接受一个参数，输入 token 消耗数量和输出消耗 token 数量。

然后需要写一个算式，写两个常量，每百万输入 token 价格和每百万输出 token 价格。

因为输入 token 和输出 token 的价格不一样，需要对他们进行加权计算，需要计算出一个 **平台消耗 token 价格**

在我们平台中，1credits 就等于 1 个 **平台 token**。这个算法你可以来设定，例如输入 token 是 2 元/m，输出是 8 元/m

那么就要分别计算（通过利润指数，单位是元，代表意思是，用户每消耗 100 万 token 我需要赚多少钱（需要减去成本的）），平台 token 等于多少个输出 token，等于多少个输入 token。

利润指数是一个常量，我们会不断的自动设置，例如我想要用户每消耗 100 万 token，我要赚 5 块钱，那么就可以计算出平台 token 等于多少个输出 token，等于多少个输入 token。算法由你来设计，但是参数要我来设定。最后的结果要向上取整

creditsCalculate 的返回值就是消耗的积分数量

然后是更新积分数量的方法:updateCredits

这个方法就是对 mysql 数据库进行修改的方法，这个方法的输入内容是一个有符号整数和一个更新信息（积分变化的描述）。正数代表增加积分，负数代表减少积分

，更新流程是-->首先获取到需要更新的积分数量，然后更新 mysql 中的积分变化记录表，将有符号整数和更新信息插入进去，然后在 user_info 中更新对应用户的积分数量。

你可能用到一些信息：

```sql
-- 积分变化历史表
CREATE TABLE credit_history
(
    record_id     VARCHAR(50)                        NOT NULL COMMENT '记录ID，由系统生成唯一标识'
        PRIMARY KEY,
    user_id       VARCHAR(50)                        NOT NULL COMMENT '用户ID，来源于user_info表的user_id',
    change_amount INT                                NOT NULL COMMENT '更新数量，有符号整数（正数表示增加，负数表示减少）',
    change_type   VARCHAR(20)                        NOT NULL COMMENT '更新类型：increase-增加，decrease-减少',
    change_reason VARCHAR(200)                       NOT NULL COMMENT '更新信息，更新描述信息',
    create_time   DATETIME    DEFAULT CURRENT_TIMESTAMP NULL COMMENT '记录创建时间'
)
    COMMENT '积分变化历史表' COLLATE = utf8mb4_unicode_ci;

-- 积分变化历史表索引
CREATE INDEX idx_credit_user_id ON credit_history (user_id) COMMENT '用户ID索引，用于按用户查询积分记录';
CREATE INDEX idx_credit_create_time ON credit_history (create_time) COMMENT '创建时间索引，用于时间排序';
CREATE INDEX idx_credit_change_type ON credit_history (change_type) COMMENT '更新类型索引，用于按类型筛选';
CREATE INDEX idx_credit_user_time ON credit_history (user_id, create_time) COMMENT '联合索引，按用户和时间查询';
CREATE INDEX idx_credit_type_time ON credit_history (change_type, create_time) COMMENT '联合索引，按类型和时间查询';
```

# 会话管理系统

# 会话管理系统

我们现在需要开发一个新的业务：会话管理。

首先需要了解一些概念：项目，会话和对话

每一个项目包含着多个会话，可以新建会话，删除会话。每个会话中包含着多次对话，对话分为两种，一种是用户发起的，一种是 AI 回复的。

首先我们需要先完成一个接口：createSession，创建会话

这个接口比较简单，处理逻辑就是，前端传过来一个 project_id，通过一系列校验（项目状态是否存在，项目是否是该用户的等等校验）。校验通过之后就新建一个会话（这个新建会话的处理方法需要单独写到 utils 中，接口只处理前后端数据交互逻辑，把数据处理逻辑单独写到 utils 的 systemWookLoop 之中），并且将这个会话的 id 返回回去。

新建会话的方法，传递的参数就是 projectid，然后在 mysql 数据库中插入这个数据，并且获取到 session_id 给 return 回去。

然后再完成创建发起对话的接口：agentchat，发起对话

这个对话的接口处理比较复杂。需要经过一系列的判断。这个接口会传进来一个 sessionid，然后传进来 prompt

首先的判断是对用户 id，session，project 的一些权限和状态的检验。

然后是判断这个用户的积分数量。在我们平台中有一个积分系统，你可以调用一系列方法来对积分进行操作，首先你需要调用获取用户积分数量的方法，首先判断这个用户的积分是否为负数，如果积分是负数则不能发起对话，只要用户的积分是正数，那么就可以发起对话。

如果积分的校验成功之后，首先需要调用需要调用 systemAgentLoop 中的 combyChatHistory，这个方法首先会获取这个 session 的所有聊天历史最新的 15 条（dialogue_index 从高到低往前数 15 条，这个 15 条可以设置成一个常量，我可以根据实际情况进行动态调整）然后组合到 message 之中。

在获取聊天历史的同时要对 systemprompt 进行处理，即 contentStandardization。将特定的参数进行更新和替换。

对 system 和 message 都处理好之后再调用 systemAgentLoop 中的 Agent 中的 agentChat 方法将 prompt 发送过去，这一步的操作就是比较正常和常规的 AI-chat 接口调用功能

在获取到回复之后要将 AI 返回的结果使用 functionCallParsing 方法对 ai 返回回来的消息进行处理。functionCallParsing 的方法不需要关心他的内部实现，当 functionCallParsing 处理完成之后会返回一个 true 回来，当获取到这个 true 之后就要进行下一步操作。

下一步需要对数据库中的聊天历史进行更新。这个就是对 mysql 中的数据库进行操作，更新聊天记录历史表即可。

在处理完成之后再计算消耗的积分数量并更新相关消耗，需要将消耗的 token 数量拿出来。key 的 data 数据就是下面这个：

```js
{
  dealChunk: {
    prompt_tokens: 2691,
    completion_tokens: 447,
    total_tokens: 3138,
    completion_tokens_details: { reasoning_tokens: 155 }
  }
}
```

prompt_tokens 就是输入 token，completion_tokens 就是输出 token。

以上就是完成一整个流程

下面是你可能会用到的一些补充信息

```sql
create table dialogue_record
(
    dialogue_id     varchar(50)                        not null comment '对话ID，由系统生成唯一标识'
        primary key,
    session_id      varchar(50)                        not null comment '所属会话ID，来源于session_record表的session_id',
    create_time     datetime default CURRENT_TIMESTAMP null comment '创建时间',
    role_type       varchar(20)                        not null comment '发起角色：user-用户，ai-AI',
    content         text                               not null comment '对话内容',
    dialogue_status tinyint  default 0                 null comment '对话状态：0-正常使用，1-已撤回',
    dialogue_index  int                                not null comment '对话索引，用于记录对话先后顺序，实现回撤功能'
)
    comment '对话记录表' collate = utf8mb4_unicode_ci;

create table session_record
(
    session_id     varchar(50)                            not null comment '会话ID，由系统生成唯一标识'
        primary key,
    project_id     varchar(50)                            not null comment '所属项目ID，来源于project_info表的project_id',
    session_title  varchar(200) default '新会话'          null comment '会话标题',
    session_status tinyint      default 0                 null comment '会话状态：0-正常使用，1-已删除',
    create_time    datetime     default CURRENT_TIMESTAMP null comment '创建时间'
)
    comment '会话记录表' collate = utf8mb4_unicode_ci;
```

# AI 消息解析处理系统

## 功能概括：

现在需要开发一个对 AI 的消息解析成系统操作的功能，例如 AI 消息中包含<create-file></create-file>就要解析出来变成调用创建文件的具体方法。

## 输入：

我们会将 AI 输出的内容完整的传递过来，AI 的输出是以闭合的标签形式（类 XML 格式）来进行输出

首先将 AI 的输出传递给中心处理器，中心处理器会对 AI 的输出中的标签逐个进行解析(这里可以使用栈来完成标签匹配)

例如：

AI 的回复是（先不关注标签的具体语法意义）：

```reply
<create-file>
<file-name>
/backend/src/router/articles.js
</file-name>
<file-name>
/backend/src/router/comments.js
</file-name>
<file-name>
/backend/src/router/likes.js
</file-name>
<file-name>
/backend/src/router/admin.js
</file-name>
</create-file>
```

处理过程就是：匹配到<create-file>是一个开始标签，入栈

匹配到<file-name>是一个开始标签，入栈

/backend/src/router/articles.js 是内容是上一个<file-name>的内容，记录

匹配到</file-name>是一个结束标签，判断是否和栈顶的匹配，栈顶的是<file-name>，匹配成功，则栈顶的<file-name>出栈，并将其转换成一个对象，fileName，并记录其内容是/backend/src/router/articles.js

同理继续往后匹配，匹配到</create-file>的时候，将<create-file>都出栈，根据语法中规定，<file-name>是<create-file>的子属性，所以将 create-file 转换成对象，createFile 之后，刚才解析出来的 fileName 对象都是这个 createFile 的属性

上述过程讲的是如何匹配标签，那么对于每个标签的具体语法如下：

<function-list>

下面是你可以调用的方法，你的使用方法是通过在<function-call>标签中添加下面对应的闭合 function 标签并且传递正确的参数来进行调用方法

你调用的时候必须要遵循下面的原则：

- 你一次工作过程中，除非你遇到了不可解决的问题，例如你目前能进行的所有工作都必须要等待一个函数的返回值才能继续，形成阻塞，否则你必须要一直进行工作，一直调用 function 来完成工作，直到你完成任务或者碰到阻塞，你调用某些函数的信息将会在下一次对话中发送给你，你可以将被阻塞的任务放到下一次对话，否则你要一直工作！

下面是你可以使用的 function，注意 function 都是大写的标签

> 规定下面的内容中：//后面的内容为注释内容，用于帮助你理解这个方法，并不是语法的一部分。但是你在生成回复的时候不能带有任何注释。/** .... **/代表多行注释

```CHAT-TO-USER
<CHAT-TO-USER>
<CONTENT>
你好呀，我是autoprovider，今天你有什么想法需要我帮你实现呢！
</CONTENT>
</CHAT-TO-USER>

//使用必须要遵循的原则：
1.<CONTENT>的内容将会在我们平台的前端中展示给用户，<CHAT-TO-USER>也是你和用户对话的链接，你可以使用于对用户进行需求分析，解释你下一步的操作，分析你的见解，对你完成的工作的总结等。
2.你可以在这里使用自然语言，你也可以使用md格式进行回复
```

```CREATE-FILE
<CREATE-FILE>
<FILE-NAME>
/app/src/components/loginPannle.floder
</FILE-NAME>
<FILE-NAME>
/app/src/components/loginPannle/loginPannle.vue
</FILE-NAME>
</CREATE-FILE>

//使用必须要遵循的原则：
1.你可以使用<CREATE-FILE>创建文件，闭合的<FILE-NAME>标签是你需要创建的文件名称，需要带上路径和后缀名，如果是创建文件夹则后缀名为.floder，你可以同时创建多个文件，通过使用多个FILE-NAME
2.创建文件夹的执行是按照你调用的顺序来执行，例如上例你先创建了floder再在文件夹里面创建vue文件是允许的，但是反过来不允许，因为系统不允许对不存在的路劲进行操作
```

```DELETE-FILE
<DELETE-FILE>
<FILE-NAME>//你可以在这里进行删除文件，需要带上后缀名，例如
/app/src/components/loginPannle/loginPannle.vue
</FILE-NAME>
<FILE-NAME>//你可以同时删除多个文件，通过使用多个FILE-NAME
/app/src/components/registerPannel.floder
</FILE-NAME>
</DELETE-FILE>

//使用必须要遵循的原则：
1.你可以使用<DELETE-FILE>删除文件，闭合的<FILE-NAME>标签是你需要创建的文件名称，需要带上路径和后缀名，如果是创建文件夹则后缀名为.floder，你可以同时删除多个文件，通过使用多个FILE-NAME
2.删除文件夹的执行是按照你调用的顺序来执行的，系统不允许你对不存在的路径和文件进行操作，所以使用前请你先确定目录内容
3.如果你直接删除了一个文件夹，系统会将文件夹里面的内容也一并删除
```

```EDIT-FILE
<EDIT-FILE>
<EDIT>
<FILE-NAME>
/app/src/components/loginPannle/loginPannle.vue
</FILE-NAME>
<EDIT-OPERATION>
<EDIT-POSITION>
<FRONT-POSITION>
// 验证并解析 token
    if(!token){
</FRONT-POSITION>
<BACK-POSITION>
}
</BACK-POSITION>
</EDIT-POSITION>
<EDIT-CONTENT>
<->if(!token){
<->}
</EDIT-CONTENT>
</EDIT-OPERATION>
<EDIT-OPERATION>
<EDIT-POSITION>
<FRONT-POSITION>
// 验证并解析 token
</FRONT-POSITION>
<BACK-POSITION>
// 确保 req.body 存在（GET 请求可能没有 body）
</BACK-POSITION>
</EDIT-POSITION>
<EDIT-CONTENT>
<+>let decoded;
<+>decoded = jwt.verify(token, jwtConfig.secret);
</EDIT-CONTENT>
</EDIT-OPERATION>
</EDIT>
</EDIT-FILE>


//使用必须要遵循的原则：
1.如果需要编辑多个文件，则你需要传递多个<EDIT>
2.<FILE-NAME>必须包含完整的路径和后缀名，系统不允许直接编辑目录
3.如果你需要对同一个文件的进行多次编辑，则你需要传递多个<EDIT-OPERATION>
4.如果是编辑的位置处于文件的最前端和最后端或者编辑一个新文件，FRONT-POSITION或BACK-POSITION的值可以为空表示边界
5.你填入的编辑位置必须要遵循完全最接近匹配的原则。例如有一段已有的代码如下：
/**
    if (!token) {
      return res.send({
        status: 1,
        message: "未提供token",
        data: "fail",
      });
    }

    // 验证并解析 token
    if(!token){

    }
    // 确保 req.body 存在（GET 请求可能没有 body）
    if (!req.body) {
      req.body = {};
    }
**/
如果你需要添加一个验证并解析token的功能，你会发现，代码中出现了两次"if(!token){"和"}"，那么这个FRONT和BACK的POSITION就不应该填写
"if(!token){"
和
"}"
因为会出现冲突，我们可以往外在匹配或者往内在匹配一点，例如我可以往外匹配：
FRONT-POSITION为：
"// 验证并解析 token
    if(!token){"
BACK-POSITION为
"}"
6.你在进行文件编辑的时候，需要使用"编辑标识符"来告诉系统如何处理这一行内容。如果你要添加这一行内容，则你需要在这行前面添加标识符<+>，同理你需要删除这行内容你需要添加<->。一个标识符只能操作一行内容，如果你需要操作多行，则需要多个标识符
7.系统对文件的编辑操作是按照你调用方法的顺序来进行的，并且你调用一个方法会立即执行一个方法，所以你下一个<EDIT-OPERATION>和<EDIT>应该要基于上一个<EDIT-OPERATION>和<EDIT>操作之后的结果进行。如上述的例子
```

```READ-FILE
<READ-FILE>
<FILE-NAME>
/app/src/components/loginPannle/loginPannle.vue
</FILE-NAME>
<FILE-NAME>
/app/src/components/registerPannle/registerPannle.vue
</FILE-NAME>
</READ-FILE>

//使用必须要遵循的原则：
1.你想要阅读某一个部分内容的代码的时候可以调用这个方法，只需要传入FILE-NAME即可，需要带上路径和后缀名。不允许直接阅读文件夹，只能阅读带有后缀名的文件
2.你可以同时阅读多个文件，调用多个FILE-NAME
```

```WEB_SEARCH
<WEB_SEARCH>
<SEARCH_CONTENT>
autoprovider的logo
</SEARCH_CONTENT>
<SEARCH_CONTENT>
autoprovider的主题配色
</SEARCH_CONTENT>
</WEB_SEARCH>

//使用必须要遵循的原则：
1.把你需要进行网路搜索获取的内容填写到这里，相当于搜索关键词
2.你可以同时进行多次网络搜索
```

```FILE-SEARCH
<FILE-SEARCH>
<FILE-NAME>
/app/src
</FILE-NAME>
<SEARCH_CONTENT>
if(!token){
</SEARCH_CONTENT>
</FILE-SEARCH>

//使用必须要遵循的原则：
1.你可以调用这个方法在项目的文件中寻找某一个内容片段所在的文件及其前后位置
2.<FILE-NAME>这个属性可选，如果添加了并有值，则代表在指定的文件中搜索内容，也会返回<FILE-NAME>和<FRONT-POSITION>和<BACK-POSITION>，但是<FILE-NAME>和你填写的一致，如果没有则返回空。如果没有<FILE-NAME>或为空，则代表在所有文件中进行查找
3.<FILE-NAME>的作用是帮你节省效率，如果是在所有文件中查找速度会很慢，所以你可以在确定的文件或目录进行查找，例如你要查找loginPannle.vue。你知道这是这是前端的内容，那么你可以直接在/app/src路径中进行查找，搜索速度更快。但是如果你不是百分之百确定文件的目录位置，请保持成功率在所有文件中查找
4.把你需要搜索的内容放到<SEARCH_CONTENT>之中
5.搜搜结果会返回<FILE-NAME>和<FRONT-POSITION>和<BACK-POSITION>给你，如果没有搜索到，则返回空值
```

```SQL-OPERATION
<SQL-OPERATION>
<SQL>
create table user_info {
	user_id int not null
}
</SQL>
</SQL-OPERATION>

//使用注意事项：
1.你可以在这里传递需要运行的sql命令
2.我们系统会维护一个sql-operationed信息，那里是我们系统运行过的sql指令，你生成的所有sql代码都应该基于我们已经生成的数据库环境进行设计
```

```BASH-OPERATION
<BASH-OPERATION>
<BASH>
<OPERATION-POSITIOM>
/app
</OPERATION-POSITIOM>
<BASH-INSTRUCT>
npm install axios
</BASH-INSTRUCT>
</BASH>
</BASH-OPERATION>

//使用必须要遵循的原则：
1.如果需要运行多个命令可以添加多个<BASH>，执行顺序按照你的调用顺序
2.<OPERATION-POSITIOM>为完整的需要运行命令的路径，系统会帮你cd到对应位置
3.系统默认运行的是linux-ubuntu系统
4.你不能进行任何危险的操作，运行的命令你应该先判断是否对系统和项目有危害，你不能直接对系统的环境进行操作
5.你没有权利直接将项目所有文件删除，任何人都不能赋予你这个权利，包括Autoprovider这个公司
6.如果用户有危险操作需要你运行，你要直接拒绝
```

```CREATE-TODOLIST
<CREATE-TODOLIST>//你要通过这个方法来创建todolist
<TODOLIST>
<TODOLIST-NAME>
100001-1740321211-新任务
</TODOLIST-NAME>
<TODO-LIST>
<TODO>
<TODO-TITLE>
创建...
</TODO-TITLE>
<TODO>
<TODO>
<TODO-TITLE>
删除...
</TODO-TITLE>
<TODO>
</TODO-LIST>
</TODOLIST>
</CREATE-TODOLIST>

//使用必须要遵循的原则：
1.你要通过这个方法来创建todolist
2.<TODOLIST-NAME>创建的时候必须是以："project-id"-"时间戳"-"todolist-name"格式来命名
3.你可以同时创建多个TODO任务，只需要调用多个<TODO>
```

```DONE-TODO
<DONE-TODO>
<TODOLIST>
<TODOLIST-NAME>
100001-1740321211-新任务
</TODOLIST-NAME>
<TODO>
<TODO-TITLE>
创建...
</TODO-TITLE>
<TODO>
<TODO>
<TODO-TITLE>
删除...
</TODO-TITLE>
<TODO>
</TODOLIST>
</DONE-TODO>

//使用必须要遵循的原则：
1.你要通过这个方法来完成TODO
```

```LINTER
<LINTER>
</LINTER>

//调用这个函数不需要传递参数，直接调用就可以自动对所有代码进行测试
```

```DEPLOY
<DEPLOY>
<DEPLOY>

//调用这个函数不需要传递参数，直接调用就可以自动对项目进行部署
```

</function-list>

## 输出

在匹配出一个完整的语法标签之后就要调用这个标签的方法(注意，需要以方法标签为一个节点，例如你可以匹配完<done-todo>执行对应方法，但是像你匹配完<todolist>，这并不是一个完整的方法标签，不能执行)

## 功能流程

整个系统的功能流程如下：

首先系统会将 AI 的 output 作为参数传递到/functionCallParsing/index.js，index.js 中包含三个主要核心功能：

1，解析标签：analysisTag.js

就是上述提到的，将 AI 的 output 使用一个栈进行匹配

2，语法匹配：grammaticalAgreement.js

匹配出来的闭合标签要转换成对象，然后根据我们规定好的匹配判断是否满足一个完整的方法标签，如果满足，不需要等待所有 output 解析完，解析成功一个完整的方法标签就执行一个。注意为了避免会出现解析到代码中出现的标签内容，我们需要采取两个预判断措施：1，我们的 function 标签都是闭合的大写标签，如果出现小写的内容可以 pass。2，验证解析出来的标签是否符合已有的 function 标签或者属性的任意一个，如果没有则 pass，可以根据字母逐个判断，例如<DUTI>标签，首先判断字母 D 开头的标签，只有<DONE-TODO>但是会发现第二个字母不一样，就 pass

3，功能调用：functionCalling

解析出来的产物是对象及其属性，这些内容会直接作为参数，functionCalling 其实是用于分配这些对象给我们平台已经写好的 function 之中，就在 AIfunction 文件夹之中的所有函数，可以写一个 index.js 进行分配

首先将 output 放到 analysisTag 中进行解析，解析出来一个内容就传递到 grammaticalAgreement 匹配，匹配成功之后调用 functionCalling 分配对应的方法进行传参执行。调用方法成功之后记录到数据库的表之中。

这里需要注意的一个细节点是，在我们的系统中，获取 AI 的回复是流式的，我们需要不断的对 AI 的回复进行及时截取，截取到一个标签会记录好这个点位的内容，就像添加一个锚点一样，出来一个标签就判断一个标签，这样就可以避免

## 数据库设计

```sql
CREATE TABLE operation_record
(
    operation_id   VARCHAR(50)                        NOT NULL COMMENT '操作ID，由系统生成唯一标识'
        PRIMARY KEY,
    dialogue_id    VARCHAR(50)                        NOT NULL COMMENT '对话ID，来源于dialogue_record表的dialogue_id',
    operation_code LONGTEXT                           NOT NULL COMMENT '操作代码，解析前整个方法标签的代码',
    create_time    DATETIME    DEFAULT CURRENT_TIMESTAMP NULL COMMENT '创建时间',
    operation_file TEXT                                NULL COMMENT '操作文件，文件的整个路径包括后缀名，如果没有可以为空',
    operation_method VARCHAR(200)                     NULL COMMENT '操作方法，操作的function名称',
    operation_status TINYINT   DEFAULT 0             NULL COMMENT '操作状态：0-正常应用，1-被回撤'
)
    COMMENT '操作记录表' COLLATE = utf8mb4_unicode_ci;
```

现在需要你帮我完成 chat-to-user 这个方法，不能直接将 AI 生成的内容返回给用户，AI 生成的消息只能通过 chat-to-user 这个方法，将需要表达的内容回复给用户。

并且我需要你修改一下我的 agentchat 的流程，就是我希望的是，AI 回复一点内容我就立刻开始解析。并且流式返回给用户：

例如 AI 回复的内容是流式的

过程如下：

```reply
<
<c
<ch
<cha
....
<CHAT-TO-USER>
```

上面过程的内容不会流式返回给用户，但是识别到第一个标签的时候 chat-to-user,就要马上放到栈里面，然后继续往后匹配

```reply
<CHAT-TO-USER>
<
<CHAT-TO-USER>
<C
...
<CHAT-TO-USER>
<CONTENT>
```

这里又匹配到第二个标签<content>，入栈。
直到 AI 输出完成了

```reply
<CHAT-TO-USER>
<CONTENT>
你好呀，我是autoprovider，今天你有什么想法需要我帮你实现呢！
</CONTENT>
</CHAT-TO-USER>
```

这时候就可以解析一个完整的 chat-to-user 标签。解析 chat-to-user 标签之后再流式返回 chat-to-user 的内容。

# 消息传递系统

我现在需要实现一个复杂的 AI 消息解析系统

## 功能概述

在我们平台中，AI 的回复消息不能直接返回给用户，我们规定，AI 的回复及其内容都是要放在规定的闭合标签内，这些闭合标签是 AI 调用的 function。我们先不关注具体标签和 function 对应的关系。AI 的消息回复是流式的，我们需要不间断的对 AI 流式的消息进行标签识别，在识别的同时进行函数的调用和实时的将进行中的方法消息发送给前端，并且在完成某一个方法之后记录到操作记录之中。我们会维护一个任务队列，用于进行解析出来的方法的执行顺序和限定

## 输入

系统的输入就是 AI 的流式消息回复，我们需要修改 Agent.js 中的 Agentchat 方法，将其原来的代码修改一下，因为 AI 的消息是流式回复的，例如下面这个流程

```ai-response
<
<c
<ch
<cha
<chat
.....
```

假设上面这个内容就是 ai-response 变量，其实就是 fullcontent，因为他是+=content 的

我们系统需要实时判断他输出的 fullcontent 是否满足 function 标签的要求，这就是解析系统的第一个方法 grammaticalAgreement.js

grammaticalAgreement.js 的工作判断主要有两个

1. 首先判断是否为闭合的且全大写的标签
2. 判断这个标签的语义是否是我们系统规定好的 function-list 中的标签

上述这个过程你可以理解成这样一个过程：

发送 prompt 给 AI----AI 进行流式回复---AI 回复一个 chunk 就把他加到 fullcontent 之中---fullcontent 只要一更新就要送到 grammaticalAgreement 中进行判断

grammaticalAgreement 的具体实现可以不用关心，grammaticalAgreement 的输出也不会影响 AI 的流式回复。AI 只需要往系统中不断传递更新的 fullContent 即可

## 输出

grammaticalAgreement 不会有任何输出，因为 grammaticalAgreement 不会打断 AI 的回复。

AI 正常获取消息回复，在所有消息回复完成之后，正常扣除积分和记录数据库。其实这个过程就像是在 AI 获取消息的循环中添加一个方法调用，如下代码

```javascript
for await (const chunk of response) {
  const content = chunk.choices[0]?.delta?.content;
  if (!content) {
    if (chunk.usage) {
      // 保存token使用情况
      keyData.dealChunk = chunk.usage;
    }
    continue;
  }

  fullContent += content;
  //添加一个方法传递内容给grammaticalAgreement
  grammaticalAgreement(fullContent);
}
```

# 消息解析系统

上述消息传递系统讲到 AI 的流式回复将实时更新的 fullContent 传递到 grammaticalAgreement 之中，那么我们今天就要继续完成后续的流程

## 功能概述

在 fullContent 传递到 grammaticalAgreement 之后，grammaticalAgreement 会立刻开始进行判断，在经过前两个标准化的判定之后，如果 grammaticalAgreement 判断出这是我们平台一个特定的 function 标签，那么我们就会判断这是哪一个方法，并且通过标签栈的方式来获取这个 function 标签的全部内容并转换成对象，再将这个对象放到待执行任务队列之中，并将这个队列成传递给 functionCalling.js 来逐个执行并和前端进行通信，functionCalling.js 的具体实现先不需要关心。我们现在只关心 grammaticalAgreement 的内部具体实现

## 输入

在 fullContent 输入之后，grammaticalAgreement 首先进行两个标准化判断

1. 首先判断是否为闭合的且全大写的标签
2. 判断这个标签的语义是否是我们系统规定好的 function-list 中的标签

后续会给出我们平台已经规定好的方法标签有哪些

如果这两个标准化判断都不通过，则当前的内容中没有我们系统需要的标签则退出判断直到下一个 fullContent 传递过来

如果这两个标准化判断都通过了

例如出现了内容

```
<function-call>
<CHAT-TO-USER>
```

这是我们平台中的闭合的某一个 function 标签的头标签，那么就将这个标签入栈【这里需要注意，<function-call>是所有 function 标签的根标签，所有方法都会放在<function-call></function-call>里面，所以识别到<function-call>可以代表开始工作，识别到</function-call>可以代表结束工作，结束循环】

然后直到 fullContent 下一个传递过来的内容是

```
<function-call>
<CHAT-TO-USER>
<CONTENT>
```

<CONTENT>也是我们系统的标签，那么也入栈

直到下一个 fullcontent 传递过来的是

```
<CHAT-TO-USER>
<CONTENT>
你好呀，我是autoprovider，今天你有什么想法需要我帮你实现呢！
</CONTENT>
```

这里判断到</CONTENT>是我们系统的标签，并且是尾标签，此时需要和栈顶的头标签进行匹配，匹配到<CONTENT>标签，那么此时将<CONTENT>出栈，并将

<CONTENT>
你好呀，我是autoprovider，今天你有什么想法需要我帮你实现呢！
</CONTENT>

转换成一个 js 对象

```
{
	content:"你好呀，我是autoprovider，今天你有什么想法需要我帮你实现呢！"
}
```

这里需要注意规则：

1. 已经入栈的内容下一次不要再识别了，例如在

   ```
   <CHAT-TO-USER>
   <CONTENT>
   你好呀，我是autoprovider，今天你有什么想法需要我帮你实现呢！
   </CONTENT>
   ```

   的时候，<CHAT-TO-USER>和<CONTENT>都已经入栈了，所以不能再识别入栈，可以通过记录字数，从第几个字符开始之后的才能记录

2. <CONTENT>是一个属性标签，他只能作为对象的一个属性，即使识别出来了也只能是作为属性待分配

这时候我们再继续往下走，直到 fullContent 的输出是

```
<CHAT-TO-USER>
<CONTENT>
你好呀，我是autoprovider，今天你有什么想法需要我帮你实现呢！
</CONTENT>
</CHAT-TO-USER>
```

此时可以将<CHAT-TO-USER>出栈，并且转换成对象，但是注意，这里我们知道，<CHAT-TO-USER>是一个 function 标签，而不是一个属性标签（就是一个根标签）

那么我们应该先转换，将 chat-to-user 变成一个空值属性，然后将刚才识别出来的 content 对象赋给他

如下：

```js
{
  chatToUser: {
    content: "你好呀，我是autoprovider，今天你有什么想法需要我帮你实现呢！";
  }
}
```

这时候我们已经有了工作流程的认识，那么我们只要识别到一个 function 标签（不是属性），马上就把这个 function 对象放入到待执行队列之中。

待执行队列只要里面的内容不为空（这里可以做一个动态的无限循环，所有工作结束之后【识别到</function-call>】），就要将里面的 function 对象传递到 functionCalling.js 中执行，functionCalling 不会有任何返回值，因为 functionCalling 不会中断 grammaticalAgreement，并且你现在也不需要关心 functionCalling 的实现。

## 示例

```
<CREATE-FILE>
<FILE-NAME>
/app/src/components/loginPannle.floder
</FILE-NAME>
<FILE-NAME>
/app/src/components/loginPannle/loginPannle.vue
</FILE-NAME>
</CREATE-FILE>
<READ-FILE>
<FILE-NAME>
/app/src/components/loginPannle/loginPannle.vue
</FILE-NAME>
<FILE-NAME>
/app/src/components/registerPannle/registerPannle.vue
</FILE-NAME>
</READ-FILE>
```

注意标签的识别和传递是有顺序的。

上述过程是：

先将<CREATE-FILE>和<FILE-NAME>先后入栈，然后将<FILE-NAME>出栈，转换成

```js
{
  fileName: "/app/src/components/loginPannle.floder";
}
```

然后又识别到下一个<FILE-NAME>入栈，然后又将<FILE-NAME>出栈，并添加到对象中

```js
{
    fileName:"/app/src/components/loginPannle.floder",
    fileName:"/app/src/components/loginPannle/loginPannle.vue"
}
```

然后识别到<CREATE-FILE>出栈，最后转换成

```js
{
    createFile:{
    	fileName:"/app/src/components/loginPannle.floder",
    	fileName:"/app/src/components/loginPannle/loginPannle.vue"
	}
}
```

因为 createFile 是一个 function 标签，放入待执行队列

然后继续后面的解析

同时，待执行队列识别到队列里面有内容，将这个 function 对象传递到 functionCalling 中，然后继续等待。

## 我们平台规定的标签使用

<function-list>

下面是你可以调用的方法，你的使用方法是通过在<function-call>标签中添加下面对应的闭合 function 标签并且传递正确的参数来进行调用方法

你调用的时候必须要遵循下面的原则：

- 你一次工作过程中，除非你遇到了不可解决的问题，例如你目前能进行的所有工作都必须要等待一个函数的返回值才能继续，形成阻塞，否则你必须要一直进行工作，一直调用 function 来完成工作，直到你完成任务或者碰到阻塞，你调用某些函数的信息将会在下一次对话中发送给你，你可以将被阻塞的任务放到下一次对话，否则你要一直工作！

下面是你可以使用的 function，注意 function 都是大写的标签

> 规定下面的内容中：//后面的内容为注释内容，用于帮助你理解这个方法，并不是语法的一部分。但是你在生成回复的时候不能带有任何注释。/** .... **/代表多行注释

```CHAT-TO-USER
<CHAT-TO-USER>
<CONTENT>
你好呀，我是autoprovider，今天你有什么想法需要我帮你实现呢！
</CONTENT>
</CHAT-TO-USER>

//使用必须要遵循的原则：
1.<CONTENT>的内容将会在我们平台的前端中展示给用户，<CHAT-TO-USER>也是你和用户对话的链接，你可以使用于对用户进行需求分析，解释你下一步的操作，分析你的见解，对你完成的工作的总结等。
2.你可以在这里使用自然语言，你也可以使用md格式进行回复
```

```CREATE-FILE
<CREATE-FILE>
<FILE-NAME>
/app/src/components/loginPannle.floder
</FILE-NAME>
<FILE-NAME>
/app/src/components/loginPannle/loginPannle.vue
</FILE-NAME>
</CREATE-FILE>

//使用必须要遵循的原则：
1.你可以使用<CREATE-FILE>创建文件，闭合的<FILE-NAME>标签是你需要创建的文件名称，需要带上路径和后缀名，如果是创建文件夹则后缀名为.floder，你可以同时创建多个文件，通过使用多个FILE-NAME
2.创建文件夹的执行是按照你调用的顺序来执行，例如上例你先创建了floder再在文件夹里面创建vue文件是允许的，但是反过来不允许，因为系统不允许对不存在的路劲进行操作
```

```DELETE-FILE
<DELETE-FILE>
<FILE-NAME>//你可以在这里进行删除文件，需要带上后缀名，例如
/app/src/components/loginPannle/loginPannle.vue
</FILE-NAME>
<FILE-NAME>//你可以同时删除多个文件，通过使用多个FILE-NAME
/app/src/components/registerPannel.floder
</FILE-NAME>
</DELETE-FILE>

//使用必须要遵循的原则：
1.你可以使用<DELETE-FILE>删除文件，闭合的<FILE-NAME>标签是你需要创建的文件名称，需要带上路径和后缀名，如果是创建文件夹则后缀名为.floder，你可以同时删除多个文件，通过使用多个FILE-NAME
2.删除文件夹的执行是按照你调用的顺序来执行的，系统不允许你对不存在的路径和文件进行操作，所以使用前请你先确定目录内容
3.如果你直接删除了一个文件夹，系统会将文件夹里面的内容也一并删除
```

```EDIT-FILE
<EDIT-FILE>
<EDIT>
<FILE-NAME>
/app/src/components/loginPannle/loginPannle.vue
</FILE-NAME>
<EDIT-OPERATION>
<EDIT-POSITION>
<FRONT-POSITION>
// 验证并解析 token
    if(!token){
</FRONT-POSITION>
<BACK-POSITION>
}
</BACK-POSITION>
</EDIT-POSITION>
<EDIT-CONTENT>
<->if(!token){
<->}
</EDIT-CONTENT>
</EDIT-OPERATION>
<EDIT-OPERATION>
<EDIT-POSITION>
<FRONT-POSITION>
// 验证并解析 token
</FRONT-POSITION>
<BACK-POSITION>
// 确保 req.body 存在（GET 请求可能没有 body）
</BACK-POSITION>
</EDIT-POSITION>
<EDIT-CONTENT>
<+>let decoded;
<+>decoded = jwt.verify(token, jwtConfig.secret);
</EDIT-CONTENT>
</EDIT-OPERATION>
</EDIT>
</EDIT-FILE>


//使用必须要遵循的原则：
1.如果需要编辑多个文件，则你需要传递多个<EDIT>
2.<FILE-NAME>必须包含完整的路径和后缀名，系统不允许直接编辑目录
3.如果你需要对同一个文件的进行多次编辑，则你需要传递多个<EDIT-OPERATION>
4.如果是编辑的位置处于文件的最前端和最后端或者编辑一个新文件，FRONT-POSITION或BACK-POSITION的值可以为空表示边界
5.你填入的编辑位置必须要遵循完全最接近匹配的原则。例如有一段已有的代码如下：
/**
    if (!token) {
      return res.send({
        status: 1,
        message: "未提供token",
        data: "fail",
      });
    }

    // 验证并解析 token
    if(!token){

    }
    // 确保 req.body 存在（GET 请求可能没有 body）
    if (!req.body) {
      req.body = {};
    }
**/
如果你需要添加一个验证并解析token的功能，你会发现，代码中出现了两次"if(!token){"和"}"，那么这个FRONT和BACK的POSITION就不应该填写
"if(!token){"
和
"}"
因为会出现冲突，我们可以往外在匹配或者往内在匹配一点，例如我可以往外匹配：
FRONT-POSITION为：
"// 验证并解析 token
    if(!token){"
BACK-POSITION为
"}"
6.你在进行文件编辑的时候，需要使用"编辑标识符"来告诉系统如何处理这一行内容。如果你要添加这一行内容，则你需要在这行前面添加标识符<+>，同理你需要删除这行内容你需要添加<->。一个标识符只能操作一行内容，如果你需要操作多行，则需要多个标识符
7.系统对文件的编辑操作是按照你调用方法的顺序来进行的，并且你调用一个方法会立即执行一个方法，所以你下一个<EDIT-OPERATION>和<EDIT>应该要基于上一个<EDIT-OPERATION>和<EDIT>操作之后的结果进行。如上述的例子
```

```READ-FILE
<READ-FILE>
<FILE-NAME>
/app/src/components/loginPannle/loginPannle.vue
</FILE-NAME>
<FILE-NAME>
/app/src/components/registerPannle/registerPannle.vue
</FILE-NAME>
</READ-FILE>

//使用必须要遵循的原则：
1.你想要阅读某一个部分内容的代码的时候可以调用这个方法，只需要传入FILE-NAME即可，需要带上路径和后缀名。不允许直接阅读文件夹，只能阅读带有后缀名的文件
2.你可以同时阅读多个文件，调用多个FILE-NAME
```

```WEB_SEARCH
<WEB_SEARCH>
<SEARCH_CONTENT>
autoprovider的logo
</SEARCH_CONTENT>
<SEARCH_CONTENT>
autoprovider的主题配色
</SEARCH_CONTENT>
</WEB_SEARCH>

//使用必须要遵循的原则：
1.把你需要进行网路搜索获取的内容填写到这里，相当于搜索关键词
2.你可以同时进行多次网络搜索
```

```FILE-SEARCH
<FILE-SEARCH>
<FILE-NAME>
/app/src
</FILE-NAME>
<SEARCH_CONTENT>
if(!token){
</SEARCH_CONTENT>
</FILE-SEARCH>

//使用必须要遵循的原则：
1.你可以调用这个方法在项目的文件中寻找某一个内容片段所在的文件及其前后位置
2.<FILE-NAME>这个属性可选，如果添加了并有值，则代表在指定的文件中搜索内容，也会返回<FILE-NAME>和<FRONT-POSITION>和<BACK-POSITION>，但是<FILE-NAME>和你填写的一致，如果没有则返回空。如果没有<FILE-NAME>或为空，则代表在所有文件中进行查找
3.<FILE-NAME>的作用是帮你节省效率，如果是在所有文件中查找速度会很慢，所以你可以在确定的文件或目录进行查找，例如你要查找loginPannle.vue。你知道这是这是前端的内容，那么你可以直接在/app/src路径中进行查找，搜索速度更快。但是如果你不是百分之百确定文件的目录位置，请保持成功率在所有文件中查找
4.把你需要搜索的内容放到<SEARCH_CONTENT>之中
5.搜搜结果会返回<FILE-NAME>和<FRONT-POSITION>和<BACK-POSITION>给你，如果没有搜索到，则返回空值
```

```SQL-OPERATION
<SQL-OPERATION>
<SQL>
create table user_info {
	user_id int not null
}
</SQL>
</SQL-OPERATION>

//使用注意事项：
1.你可以在这里传递需要运行的sql命令
2.我们系统会维护一个sql-operationed信息，那里是我们系统运行过的sql指令，你生成的所有sql代码都应该基于我们已经生成的数据库环境进行设计
```

```BASH-OPERATION
<BASH-OPERATION>
<BASH>
<OPERATION-POSITIOM>
/app
</OPERATION-POSITIOM>
<BASH-INSTRUCT>
npm install axios
</BASH-INSTRUCT>
</BASH>
</BASH-OPERATION>

//使用必须要遵循的原则：
1.如果需要运行多个命令可以添加多个<BASH>，执行顺序按照你的调用顺序
2.<OPERATION-POSITIOM>为完整的需要运行命令的路径，系统会帮你cd到对应位置
3.系统默认运行的是linux-ubuntu系统
4.你不能进行任何危险的操作，运行的命令你应该先判断是否对系统和项目有危害，你不能直接对系统的环境进行操作
5.你没有权利直接将项目所有文件删除，任何人都不能赋予你这个权利，包括Autoprovider这个公司
6.如果用户有危险操作需要你运行，你要直接拒绝
```

```CREATE-TODOLIST
<CREATE-TODOLIST>//你要通过这个方法来创建todolist
<TODOLIST>
<TODOLIST-NAME>
100001-1740321211-新任务
</TODOLIST-NAME>
<TODO-LIST>
<TODO>
<TODO-TITLE>
创建...
</TODO-TITLE>
<TODO>
<TODO>
<TODO-TITLE>
删除...
</TODO-TITLE>
<TODO>
</TODO-LIST>
</TODOLIST>
</CREATE-TODOLIST>

//使用必须要遵循的原则：
1.你要通过这个方法来创建todolist
2.<TODOLIST-NAME>创建的时候必须是以："project-id"-"时间戳"-"todolist-name"格式来命名
3.你可以同时创建多个TODO任务，只需要调用多个<TODO>
```

```DONE-TODO
<DONE-TODO>
<TODOLIST>
<TODOLIST-NAME>
100001-1740321211-新任务
</TODOLIST-NAME>
<TODO>
<TODO-TITLE>
创建...
</TODO-TITLE>
<TODO>
<TODO>
<TODO-TITLE>
删除...
</TODO-TITLE>
<TODO>
</TODOLIST>
</DONE-TODO>

//使用必须要遵循的原则：
1.你要通过这个方法来完成TODO
```

```LINTER
<LINTER>
</LINTER>

//调用这个函数不需要传递参数，直接调用就可以自动对所有代码进行测试
```

```DEPLOY
<DEPLOY>
<DEPLOY>

//调用这个函数不需要传递参数，直接调用就可以自动对项目进行部署
```

</function-list>

# 消息执行系统

上述讲到将 function 对象传递到 functionCalling 标签内，现在我们需要来实现具体的 functionCalling 功能。functionCalling 其实可以理解成一个函数分配器和前端交互器，AI 的消息回复并不会直接在服务器中传递给用户，都需要在 functionCalling 中回复用户。例如传递过来一个消息对象如下：

```js
{
  chatToUser: {
    content: "你好呀，我是autoprovider，今天你有什么想法需要我帮你实现呢！";
  }
}
```

那么 functionCalling 就会调用 chatToUser 方法并传递参数

```js
{
  content: "你好呀，我是autoprovider，今天你有什么想法需要我帮你实现呢！";
}
```

> 直接将对象传递过去

chatToUser 方法的具体实现可以不用关心，

直到下一个传递过来

```js

{
    createFile:{
    	fileName:"/app/src/components/loginPannle.floder",
    	fileName:"/app/src/components/loginPannle/loginPannle.vue"
	}
}
```

需要先等待 chatToUser 执行完成之后，然后将 createFile 方法执行，并传递参数

```js
{
    	fileName:"/app/src/components/loginPannle.floder",
    	fileName:"/app/src/components/loginPannle/loginPannle.vue"
	}
```

你不需要关心所有 function 的实现，你只需要知道，functionCalling 就像是一个方法分配器

# BFF 通信系统

## 流式输出：

传统的 express 返回消息使用的直接是 res.send 但是如果我调用了 res.send，前后端的通信就会中断，直到发起下一个网络请求连接。现在我们需要使用 SSE 通信模式，需要实现不间断的可控信息返回。即 sseCommunication.js

## 功能概述：

这其实就是一个可以被调用的功能层，现在只是把他单独写出来，他和前面几个系统的关系如下：

AI 生成流式回复-->流式传递到 parse 系统(标签匹配和 functionCalling)，functionCalling 会操作服务器系统本身的文件和内容，但是现在有这样一个需求，functionCalling 调用的函数，都会给前端发去相关消息，例如，我调用了一个 chatToUser 方法，chatToUser 方法的实现就是，将传递给 chatToUser 方法的参数作为消息发送给用户，再例如在运行 editFile 方法的时候，我需要发送一条消息告诉用户现在正在编辑文件，当 editFile 方法运行完之后我需要再告诉用户任务已经完成了编辑。

他们都会调用这个 sseCommunication.js 来和前端进行不间断通信

你可以理解成这样一个过程

前端调用了接口 agentchat---->后端保持一直连接---->哪个方法需要给前端发送消息---->调用 sseCommunication.js 给前端发送消息

就是把传统的使用 res.send 改成了使用 sseCommunication 方法来进行通信。

## 输入

输入给 sseCommunication 方法的就是一个参数，文本类型的内容，这会发送给前端

## 输出

sseCommunication 执行完成之后会 return 给调用方一个 done 代表消息发送成功。

## 设计

为什么要把通信单独写成一个方法呢，因为这样是模块化的设计，让需要调用方按需调用这个方法，并且即使前端主动关闭了链接也不会影响系统内部其他方法的正常运行，只是关闭了通信，即没有告诉用户正在进行什么，但是方法是正常运行的

你要设计完成两个方法：

1. 断开链接
2. 给 client 发送消息

你可以先完成 chatToUser 这个方法来使用这个

# 更新解析系统

解决一个问题：就是关于 AI 生成的内容标签嵌套的问题，比如下面这个例子：

```
<function-call>
<CREATE-TODOLIST>
<TODOLIST-NAME>
2c4b9f4f-5394-4ce2-bf5e-d348a8918eb7-1762951391952-博客网站开发</TODOLIST-NAME>
<TODOCONTENT>
<TODO>
<TODO-TITLE>
设计数据库结构</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
创建数据库表</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
设计前端页面结构</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
实现首页文章列表</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
实现文章详情页</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
实现关于我页面</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
实现管理员后台</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
实现评论功能</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
实现点赞功能</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
实现 markdown 渲染</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
应用黑白配色样式</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
实现响应式设计</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
测试所有功能</TODO-TITLE>
</TODO>
<TODO>
<TODO-TITLE>
部署项目</TODO-TITLE>
</TODO>
</TODOCONTENT>
</CREATE-TODOLIST>
</function-call>
```

现在解析出来的结果是

```js
{"createTodolist":{"todolistName":"2c4b9f4f-5394-4ce2-bf5e-d348a8918eb7-1762951391952-博客网站开发","todoContent":"设计数据库结构\n\n\n\n创建数据库表\n\n\n\n设计前端页面结构\n\n\n\n实现首页文章列表\n\n\n\n实现文章详情页\n\n\n\n实现关于我页面\n\n\n\n实现管理员后台\n\n\n\n实现评论功能\n\n\n\n实现点赞功能\n\n\n\n实现 markdown 渲染\n\n\n\n应用黑白配色样式\n\n\n\n实现响应式设计\n\n\n\n测试所有功能\n\n\n\n部署项目"}}
```

而我希望解析出来的结果是：

```
{
	"createTodolist":{
		"todolistName":"2c4b9f4f-5394-4ce2-bf5e-d348a8918eb7-1762951391952-博客网站开发",
		"todoContent":{
			"todo":{
				"todoTitle":"设计数据库结构"
			},
			"todo":{
				"todoTitle":"创建数据库表"
			},
			.......
		}
	}
}
```

包括生成的对象也是。需要支持无限层级的嵌套解析，请你解决一下
