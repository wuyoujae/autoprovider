1. 首先完成 level1，判断
2. 然后完成 level2，进行需求分析，需求分析完成之后生成 demand analysis results
3. 将 demand analysis results 发送到 level3，这个 level 会将 demand analysis results 中的上下文文件读取成代码，添加到 context history
4. 到了 level4，会将 context history 添加各种补充信息。组合成“preinstall messages”
5. 然后将这个“preinstall messages”发送回给 coding Agent
6. 在 coding Agent 工作之前清空 new fileOperation record，在 coding Agent 开始工作之后，如果 coding Agent 编辑了文件，那么将这些文件更新一下（new fileOperation record）中【只记录编辑 的文件名】并且修改更新到 dialogue_record 表的内容，不存储完整的编辑情况，只记录关键信息：“编辑了操作 xxxxx"。并且将所有操作都更新到操作手册中，因为例如 readfile 这些还是会有不相关代码内容出现。【对于 readfile 的记录。只记入 dialogue_record，操作手册只记录增删改操作，查操作不记录】
7. 在 coding Agent 完成工作之后，进入 role 为 system 的工作循环，这时候直接从 level1 进入 level5。在这个 level 中，我们首先会获取记录在数据库中的 demand analysis results。然后判断 new fileOperation record 是否有内容，如果 new fileOperation record 有内容，那么将 new fileOperation record 中编辑过的文件（和 demand analysis results 已有的文件去重）添加到 demand analysis results 中并更新数据库中记录的 demand analysis results。然后根据现在的 demand analysis results 来获取一遍所有记录文件中的代码组合成 context history，然后再添加各种补充信息，组合成“preinstall messages”。然后再获取再获取 dialogue_record 中当前 work 的所有历史消息，将他们打包发送回给 coding Agent。并且更新 todolist
8. 当上下文 token 达到了 limit。例如如果要加入下一条消息的时候超过了上下文，那么我们会进行压缩上下文的处理。具体操作是将本次 work 中 dialogue_record 的消息进行压缩【压缩策略就是将他们全部压缩成一条消息。对他们进行概括总结】
